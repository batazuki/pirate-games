<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Skeleton Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            padding: 10px;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 0 10px;
        }

        .nav-btn {
            padding: 10px 20px;
            font-size: clamp(0.85em, 2.5vw, 1em);
            background: #3a3a50;
            color: #fff;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            flex: 1 1 auto;
            min-width: 140px;
            max-width: 220px;
        }

        .nav-btn:hover {
            background: #4a4a60;
            border-color: #f0a500;
        }

        .nav-btn.active {
            background: #f0a500;
            color: #1a1a2e;
            border-color: #f0a500;
        }

        .game-section {
            display: none;
        }

        .game-section.active {
            display: block;
        }

        h1 {
            text-align: center;
            font-size: clamp(1.5em, 5vw, 2.5em);
            margin-bottom: 10px;
            color: #f0a500;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .subtitle {
            text-align: center;
            font-size: clamp(0.9em, 3vw, 1.2em);
            margin-bottom: 20px;
            color: #ddd;
        }

        /* Matching Game Styles */
        .match-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            max-width: 1000px;
            margin: 20px auto;
            padding: 10px;
        }

        .flag-card {
            background: transparent;
            border: none;
            cursor: pointer;
            min-height: 160px;
            perspective: 1000px;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 160px;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flag-card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #444;
        }

        .card-front {
            background: #2a2a40;
        }

        .card-back {
            background: #1a1a2e;
            transform: rotateY(180deg);
            padding: 10px;
        }

        .flag-card:hover .card-face {
            border-color: #f0a500;
        }

        .flag-card.matched .card-face {
            border-color: #4ecca3;
            background: #2d4a3e;
        }

        .flag-card.matched {
            cursor: not-allowed;
        }

        .flag-card.wrong .card-inner {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: rotateY(180deg) translateX(0); }
            25% { transform: rotateY(180deg) translateX(-10px); }
            75% { transform: rotateY(180deg) translateX(10px); }
        }

        .flag-svg {
            width: 100%;
            height: auto;
            max-height: 180px;
        }

        .skull-icon {
            font-size: 60px;
            color: #f0a500;
        }

        .match-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        /* Whack-a-Skeleton Game Styles */
        .whack-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Treasure Hunt Game Styles */
        .treasure-container {
            max-width: 600px;
            margin: 0 auto;
        }

        /* Find Brook Game Styles */
        .brook-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Rhythm Dance Party Game Styles */
        .rhythm-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .rhythm-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .rhythm-canvas-wrapper {
            position: relative;
            background: #1a1a2e;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        #rhythmCanvas {
            display: block;
            border: 3px solid #f0a500;
            border-radius: 10px;
            background: #0f0f1e;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        .dance-skeleton {
            position: absolute;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .dance-skeleton:hover {
            transform: scale(1.1);
        }

        .dance-skeleton.pulse {
            animation: skeletonPulse 0.5s ease;
        }

        @keyframes skeletonPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); border-color: #4ecca3; }
        }

        .rhythm-hit {
            position: absolute;
            font-size: 2em;
            font-weight: bold;
            color: #4ecca3;
            animation: hitFloat 0.8s ease-out forwards;
            pointer-events: none;
        }

        @keyframes hitFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .combo-display {
            text-align: center;
            font-size: 2.5em;
            font-weight: bold;
            color: #f0a500;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .rhythm-note {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #f0a500;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            animation: noteFloat 2s linear;
            pointer-events: none;
        }

        @keyframes noteFloat {
            from { transform: translateY(-50px); opacity: 1; }
            to { transform: translateY(500px); opacity: 0; }
        }

        @media (max-width: 768px) {
            .rhythm-container {
                padding: 10px;
            }

            #rhythmCanvas {
                width: 100%;
                height: auto;
            }

            .rhythm-stats {
                gap: 10px;
            }

            .stat-box {
                min-width: 90px;
                padding: 10px 15px;
            }

            .stat-value {
                font-size: 1.5em;
            }
        }

        @media (max-width: 480px) {
            .rhythm-canvas-wrapper {
                padding: 10px;
            }

            .rhythm-stats {
                flex-direction: row;
                justify-content: space-between;
            }

            .stat-box {
                min-width: 80px;
                padding: 8px 12px;
            }

            .stat-label {
                font-size: 0.75em;
            }

            .stat-value {
                font-size: 1.3em;
            }
        }

        .brook-canvas-wrapper {
            position: relative;
            background: #2a2a40;
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            overflow: hidden;
        }

        #brookCanvas {
            display: block;
            border: 3px solid #f0a500;
            border-radius: 10px;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
            background: #1a1a2e;
            touch-action: none;
        }

        .brook-timer {
            text-align: center;
            margin-bottom: 20px;
        }

        .timer-value {
            font-size: 3em;
            font-weight: bold;
            color: #f0a500;
        }

        .brook-hint {
            text-align: center;
            background: #2a2a40;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #f0a500;
        }

        .brook-hint-text {
            font-size: 1.1em;
            color: #ddd;
        }

        .skeleton-marker {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid #4ecca3;
            border-radius: 50%;
            pointer-events: none;
            animation: foundPulse 0.6s ease-out;
        }

        @keyframes foundPulse {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        @media (max-width: 768px) {
            .brook-container {
                padding: 10px;
            }

            #brookCanvas {
                width: 100%;
                height: auto;
            }

            .brook-hint {
                padding: 12px;
            }

            .brook-hint-text {
                font-size: 1em;
            }

            .treasure-info {
                margin-bottom: 15px;
            }
        }

        @media (max-width: 480px) {
            .brook-canvas-wrapper {
                padding: 10px;
            }

            .brook-hint {
                padding: 10px;
            }

            .brook-hint-text {
                font-size: 0.9em;
                line-height: 1.4;
            }

            .treasure-list {
                gap: 8px;
            }

            .treasure-icon {
                font-size: 1.5em;
            }
        }

        .treasure-canvas-wrapper {
            position: relative;
            background: #2a2a40;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        #treasureCanvas {
            display: block;
            border: 3px solid #f0a500;
            border-radius: 10px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><circle cx="12" cy="12" r="8" fill="rgba(255,255,255,0.5)" stroke="%23f0a500" stroke-width="2"/></svg>') 12 12, crosshair;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }

        .treasure-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .treasure-item {
            background: #2a2a40;
            padding: 12px 20px;
            border-radius: 10px;
            border: 2px solid #f0a500;
            text-align: center;
            min-width: 140px;
        }

        .treasure-label {
            font-size: 0.9em;
            color: #ddd;
            margin-bottom: 5px;
        }

        .treasure-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #f0a500;
        }

        .treasure-list {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .treasure-icon {
            font-size: 2em;
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .treasure-icon.found {
            opacity: 1;
            animation: treasureFound 0.5s ease;
        }

        @keyframes treasureFound {
            0% { transform: scale(1); }
            50% { transform: scale(1.5) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat-box {
            background: #2a2a40;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #f0a500;
            text-align: center;
            min-width: 120px;
        }

        .stat-label {
            font-size: 0.9em;
            color: #ddd;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #f0a500;
        }

        .graves-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            max-width: 600px;
            margin: 0 auto 30px;
        }

        .grave {
            position: relative;
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            overflow: hidden; /* Hide skeleton when below ground */
        }

        .grave-stone {
            width: 100%;
            height: 100px;
            background: linear-gradient(135deg, #555, #333);
            border-radius: 50% 50% 0 0 / 30% 30% 0 0;
            position: relative;
            z-index: 3;
            border: 3px solid #222;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
        }

        .grave-base {
            width: 110%;
            height: 30px;
            background: #2a4a2a;
            border-radius: 5px;
            position: relative;
            z-index: 3;
            margin-top: -5px;
        }

        .skeleton-popup {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(150px);
            width: 100px;
            height: 130px;
            z-index: 2;
            transition: transform 0.25s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }

        .skeleton-popup.active {
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
            cursor: pointer;
        }

        .skeleton-popup.whacked {
            animation: shatter 0.4s ease-out forwards;
            pointer-events: none;
        }

        @keyframes shatter {
            0% { transform: translateX(-50%) translateY(0) scale(1) rotate(0deg); opacity: 1; }
            50% { transform: translateX(-50%) translateY(-30px) scale(1.3) rotate(10deg); }
            100% { transform: translateX(-50%) translateY(-60px) scale(0.3) rotate(180deg); opacity: 0; }
        }

        .skeleton-head {
            width: 85px;
            height: 95px;
            background: #ffffff;
            border-radius: 50% 50% 45% 45%;
            position: relative;
            margin: 0 auto;
            border: 4px solid #000;
            box-shadow: 0 8px 15px rgba(0,0,0,0.5);
        }

        .skeleton-eye {
            width: 18px;
            height: 18px;
            background: #000;
            border-radius: 50%;
            position: absolute;
            top: 25px;
        }

        .skeleton-eye.left {
            left: 15px;
        }

        .skeleton-eye.right {
            right: 15px;
        }

        .skeleton-nose {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 14px solid #000;
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
        }

        .skeleton-mouth {
            width: 40px;
            height: 4px;
            background: #000;
            position: absolute;
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
        }

        .skeleton-teeth {
            display: flex;
            gap: 3px;
            position: absolute;
            bottom: 22px;
            left: 50%;
            transform: translateX(-50%);
        }

        .skeleton-tooth {
            width: 7px;
            height: 10px;
            background: #000;
            border-radius: 0 0 2px 2px;
        }

        .points-popup {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecca3;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
        }

        /* Excavation Game Styles */

        .game-container {
            position: relative;
            max-width: 500px;
            width: 100%;
            margin: 0 auto;
        }

        .canvas-wrapper {
            position: relative;
            background: #2a2a40;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #scratchCanvas {
            display: block;
            border: 3px solid #f0a500;
            border-radius: 10px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><circle cx="12" cy="12" r="8" fill="rgba(255,255,255,0.5)" stroke="%23f0a500" stroke-width="2"/></svg>') 12 12, crosshair;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }

        .progress-container {
            margin-top: 20px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            max-width: 400px;
            height: 30px;
            background: #2a2a40;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px auto;
            border: 2px solid #555;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f0a500, #ffb520);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #1a1a2e;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 25px;
            font-size: clamp(0.9em, 2.5vw, 1.1em);
            background: #f0a500;
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            background: #ffb520;
        }

        .btn:active {
            transform: translateY(0);
        }

        .victory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #f0a500;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }

        .victory.show {
            display: block;
            animation: victoryPop 0.5s ease;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 35px;
            height: 35px;
            background: #f0a500;
            color: #1a1a2e;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            line-height: 1;
            padding: 0;
        }

        .close-btn:hover {
            background: #ffb520;
            transform: rotate(90deg);
        }

        @keyframes victoryPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .victory h2 {
            font-size: 2.5em;
            color: #4ecca3;
            margin-bottom: 10px;
        }

        .victory p {
            font-size: 1.2em;
            color: #ddd;
            margin-bottom: 20px;
        }

        .skeleton-dance {
            animation: dance 1s ease-in-out infinite;
        }

        @keyframes dance {
            0%, 100% { transform: rotate(0deg) translateY(0); }
            25% { transform: rotate(-5deg) translateY(-10px); }
            50% { transform: rotate(5deg) translateY(0); }
            75% { transform: rotate(-3deg) translateY(-10px); }
        }

        @media (max-width: 768px) {
            .canvas-wrapper {
                padding: 15px;
            }

            .controls {
                gap: 10px;
            }

            .btn {
                padding: 10px 20px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .canvas-wrapper {
                padding: 10px;
            }

            .victory {
                padding: 30px 20px;
                max-width: 90%;
            }

            .victory h2 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <!-- Game Navigation -->
    <div class="game-nav">
        <button class="nav-btn active" id="nav-excavation" onclick="showExcavationGame()">üèúÔ∏è Excavation</button>
        <button class="nav-btn" id="nav-treasure" onclick="showTreasureGame()">üíé Treasure Hunt</button>
        <button class="nav-btn" id="nav-brook" onclick="showBrookGame()">üé∏ Find Brook</button>
        <button class="nav-btn" id="nav-rhythm" onclick="showRhythmGame()">üéµ Dance Party</button>
        <button class="nav-btn" id="nav-whack" onclick="showWhackGame()">‚ö∞Ô∏è Whack Skeletons</button>
        <button class="nav-btn" id="nav-flags" onclick="showFlagGame()">üè¥‚Äç‚ò†Ô∏è Match Flags</button>
    </div>

    <!-- EXCAVATION GAME -->
    <div id="excavation-game" class="game-section active">
    <h1>üíÄ Skeleton Excavation üíÄ</h1>
    <div class="subtitle">Brush away the sand to uncover the skeleton!</div>

    <div class="game-container">
        <div class="canvas-wrapper">
            <canvas id="scratchCanvas" width="400" height="550"></canvas>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" onclick="resetGame()">üîÑ New Excavation</button>
            <button class="btn" onclick="revealAll()">üëÅÔ∏è Reveal All</button>
        </div>
    </div>
    </div>

    <!-- MATCHING GAME -->
    <div id="match-game" class="game-section">
        <h1>üè¥‚Äç‚ò†Ô∏è Pirate Flag Matching Game üè¥‚Äç‚ò†Ô∏è</h1>
        <div class="subtitle">Match the identical pirate flags!</div>
        
        <div class="match-info">
            Pairs Found: <span class="found-count" id="pairsCount">0</span> / 6
        </div>

        <div class="match-grid" id="flagGrid"></div>

        <div class="controls">
            <button class="btn" onclick="resetMatchGame()">üîÑ New Game</button>
        </div>

        <div class="victory" id="match-victory" style="display:none;">
            <button class="close-btn" onclick="closeMatchVictory()">√ó</button>
            <h2>üéâ All Flags Matched! üéâ</h2>
            <p>You've matched all the pirate flags!</p>
            <button class="btn" onclick="resetMatchGame()">Play Again</button>
        </div>
    </div>

    <!-- RHYTHM DANCE PARTY GAME -->
    <div id="rhythm-game" class="game-section">
        <h1>üéµ Skeleton Dance Party üéµ</h1>
        <div class="subtitle">Click the dancing skeletons to the beat! ‚ô™ Yohohoho! ‚ô™</div>

        <div class="rhythm-container">
            <div class="rhythm-stats">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="rhythm-score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Combo</div>
                    <div class="stat-value" id="rhythm-combo">0x</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Perfect</div>
                    <div class="stat-value" id="rhythm-perfect">0</div>
                </div>
            </div>

            <div class="rhythm-canvas-wrapper" id="rhythm-canvas-wrapper">
                <canvas id="rhythmCanvas" width="700" height="500"></canvas>
            </div>

            <div class="controls">
                <button class="btn" id="rhythm-start-btn" onclick="startRhythmGame()">üéÆ Start Dance Party</button>
                <button class="btn" onclick="resetRhythmGame()" style="display:none;" id="rhythm-reset-btn">üîÑ Play Again</button>
            </div>
        </div>

        <div class="victory" id="rhythm-victory" style="display:none;">
            <button class="close-btn" onclick="closeRhythmVictory()">√ó</button>
            <h2>üéâ Dance Complete! üéâ</h2>
            <p>Yohohoho! What a performance!</p>
            <p>Final Score: <span id="rhythm-final-score">0</span></p>
            <p>Perfect Hits: <span id="rhythm-final-perfect">0</span></p>
            <button class="btn" onclick="resetRhythmGame()">Dance Again</button>
        </div>
    </div>

    <!-- WHACK-A-SKELETON GAME -->
    <div id="whack-game" class="game-section">
        <h1>‚ö∞Ô∏è Whack-a-Skeleton ‚ö∞Ô∏è</h1>
        <div class="subtitle">Smash the skeleton heads as fast as you can!</div>

        <div class="whack-container">
            <div class="game-stats">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="whack-score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="whack-time">60</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Combo</div>
                    <div class="stat-value" id="whack-combo">0</div>
                </div>
            </div>

            <div class="graves-grid" id="gravesGrid"></div>

            <div class="controls">
                <button class="btn" id="whack-start-btn" onclick="startWhackGame()">üéÆ Start Game</button>
                <button class="btn" onclick="resetWhackGame()" style="display:none;" id="whack-reset-btn">üîÑ Play Again</button>
            </div>
        </div>

        <div class="victory" id="whack-victory" style="display:none;">
            <button class="close-btn" onclick="closeWhackVictory()">√ó</button>
            <h2>‚ö∞Ô∏è Game Over! ‚ö∞Ô∏è</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <p>Skeletons Whacked: <span id="final-whacks">0</span></p>
            <button class="btn" onclick="resetWhackGame()">Play Again</button>
        </div>
    </div>

    <!-- TREASURE HUNT GAME -->
    <div id="treasure-game" class="game-section">
        <h1>üíé Treasure Hunt üíé</h1>
        <div class="subtitle">Uncover all the hidden treasures!</div>

        <div class="treasure-container">
            <div class="treasure-info">
                <div class="treasure-item">
                    <div class="treasure-label">Found</div>
                    <div class="treasure-value" id="treasure-found">0 / 8</div>
                </div>
            </div>

            <div class="treasure-list">
                <span class="treasure-icon" id="treasure-0">üí∞</span>
                <span class="treasure-icon" id="treasure-1">üíé</span>
                <span class="treasure-icon" id="treasure-2">üëë</span>
                <span class="treasure-icon" id="treasure-3">üìø</span>
                <span class="treasure-icon" id="treasure-4">üíç</span>
                <span class="treasure-icon" id="treasure-5">üèÜ</span>
                <span class="treasure-icon" id="treasure-6">üëí</span>
                <span class="treasure-icon" id="treasure-7">üê≠</span>
            </div>

            <div class="treasure-canvas-wrapper">
                <canvas id="treasureCanvas" width="500" height="600"></canvas>
            </div>

            <div class="controls">
                <button class="btn" onclick="resetTreasureGame()">üîÑ New Hunt</button>
                <button class="btn" onclick="revealAllTreasure()">üëÅÔ∏è Reveal All</button>
            </div>
        </div>

        <div class="victory" id="treasure-victory" style="display:none;">
            <button class="close-btn" onclick="closeTreasureVictory()">√ó</button>
            <h2>üéâ All Treasures Found! üéâ</h2>
            <p>You discovered all the hidden treasures!</p>
            <p>(Including the silly straw hat üëí and the mysterious mouse! üê≠)</p>
            <button class="btn" onclick="resetTreasureGame()">Hunt Again</button>
        </div>
    </div>

    <!-- FIND BROOK GAME -->
    <div id="brook-game" class="game-section">
        <h1>üé∏ Find Brook! üé∏</h1>
        <div class="subtitle">Can you spot Brook with his afro among all these skeletons?</div>

        <div class="brook-container">
            <div class="brook-hint">
                <div class="brook-hint-text">
                    üéµ Find all 4 special skeletons! üéµ<br>
                    <strong>Brook with Afro</strong> ‚Ä¢ <strong>Straw Hat</strong> ‚Ä¢ <strong>Violin</strong> ‚Ä¢ <strong>Milk Bottle</strong>
                </div>
            </div>

            <div class="treasure-info" style="margin-bottom: 20px;">
                <div class="treasure-item">
                    <div class="treasure-label">Found</div>
                    <div class="treasure-value" id="brook-found">0 / 4</div>
                </div>
            </div>

            <div class="treasure-list" style="margin-bottom: 20px;">
                <span class="treasure-icon" id="brook-icon-brook">üíÄ</span>
                <span class="treasure-icon" id="brook-icon-hat">üëí</span>
                <span class="treasure-icon" id="brook-icon-violin">üéª</span>
                <span class="treasure-icon" id="brook-icon-milk">ü•õ</span>
            </div>

            <div class="brook-canvas-wrapper" id="brook-canvas-wrapper">
                <canvas id="brookCanvas" width="600" height="800"></canvas>
            </div>

            <div class="controls">
                <button class="btn" onclick="resetBrookGame()">üîÑ New Game</button>
            </div>
        </div>

        <div class="victory" id="brook-victory" style="display:none;">
            <button class="close-btn" onclick="closeBrookVictory()">√ó</button>
            <h2>üéâ You Found Everyone! üéâ</h2>
            <p>Yohohoho! You found Brook and all his pirate friends!</p>
            <p>üé∏ Brook ‚Ä¢ üëí Luffy's Hat ‚Ä¢ üéª Violin ‚Ä¢ ü•õ Milk</p>
            <button class="btn" onclick="resetBrookGame()">Play Again</button>
        </div>
    </div>

    <div class="victory" id="victoryMessage">
        <button class="close-btn" onclick="closeVictory()">√ó</button>
        <h2>üéâ Skeleton Discovered! üéâ</h2>
        <p>You've successfully uncovered the ancient skeleton!</p>
        <button class="btn" onclick="resetGame()">Excavate Another</button>
    </div>

    <script>
        const canvas = document.getElementById('scratchCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const progressFill = document.getElementById('progressFill');
        const victoryMessage = document.getElementById('victoryMessage');

        let isDrawing = false;
        let scratchedPixels = 0;
        let totalPixels = 0;
        let gameComplete = false;

        // Create separate canvases
        let sandCanvas;
        let sandCtx;
        let skeletonCanvas;
        let skeletonCtx;

        // Brush settings
        const brushSize = 30;

        // Progress check throttle
        let progressCheckCounter = 0;

        function initGame() {
            gameComplete = false;
            scratchedPixels = 0;
            progressCheckCounter = 0;
            victoryMessage.classList.remove('show');
            canvas.classList.remove('skeleton-dance');

            // Create skeleton canvas (drawn once and cached)
            skeletonCanvas = document.createElement('canvas');
            skeletonCanvas.width = canvas.width;
            skeletonCanvas.height = canvas.height;
            skeletonCtx = skeletonCanvas.getContext('2d');

            // Create sand canvas
            sandCanvas = document.createElement('canvas');
            sandCanvas.width = canvas.width;
            sandCanvas.height = canvas.height;
            sandCtx = sandCanvas.getContext('2d');

            // Draw skeleton once on its own canvas
            drawSkeletonOnCanvas(skeletonCtx);

            // Draw sand on sand canvas
            drawSandOverlay();

            // Initial composite
            updateDisplay();

            // Calculate total pixels for progress tracking
            totalPixels = canvas.width * canvas.height;

            updateProgress();
        }

        function drawSkeletonOnCanvas(context) {
            // Dark background for contrast
            context.fillStyle = '#1a1a2e';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bright white skeleton with thick outlines
            context.fillStyle = '#ffffff';
            context.strokeStyle = '#000000';
            context.lineWidth = 3;

            // Skull - larger and centered
            context.beginPath();
            context.ellipse(200, 100, 70, 75, 0, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            // Eyes - larger
            context.fillStyle = '#000000';
            context.beginPath();
            context.arc(170, 90, 18, 0, Math.PI * 2);
            context.fill();
            context.beginPath();
            context.arc(230, 90, 18, 0, Math.PI * 2);
            context.fill();

            // Nose - larger
            context.beginPath();
            context.moveTo(200, 110);
            context.lineTo(185, 135);
            context.lineTo(215, 135);
            context.closePath();
            context.fill();

            // Teeth - larger and more visible
            context.fillRect(165, 150, 15, 12);
            context.fillRect(185, 150, 15, 12);
            context.fillRect(200, 150, 15, 12);
            context.fillRect(220, 150, 15, 12);

            // Pirate Hat - larger
            context.fillStyle = '#000000';
            context.beginPath();
            context.moveTo(120, 35);
            context.lineTo(280, 35);
            context.lineTo(268, 75);
            context.lineTo(132, 75);
            context.closePath();
            context.fill();
            context.stroke();

            context.beginPath();
            context.ellipse(200, 35, 85, 18, 0, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            context.fillStyle = '#ffffff';
            context.font = 'bold 35px Arial';
            context.fillText('‚ò†', 180, 63);

            // Spine and Ribcage - thicker and more visible
            context.fillStyle = '#ffffff';
            context.fillRect(190, 185, 20, 130);
            context.strokeRect(190, 185, 20, 130);

            // Ribs - larger and more prominent
            context.lineWidth = 6;
            for (let i = 0; i < 4; i++) {
                const y = 210 + i * 30;
                const width = 65 - i * 5;
                context.beginPath();
                context.ellipse(200, y, width, 12, 0, 0, Math.PI * 2);
                context.stroke();
            }

            context.lineWidth = 3;

            // Pelvis - larger
            context.beginPath();
            context.ellipse(200, 325, 50, 30, 0, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            // Arms - larger and more visible
            drawArmOnCanvas(context, 110, 190, 80, 15, -35, 80, 205, 70, 15, true);
            drawArmOnCanvas(context, 210, 190, 80, 15, 35, 250, 205, 70, 15, false);

            // Legs - larger
            drawLegOnCanvas(context, 165, 350, 18, 140, 155, 490, 18, 100, -12, true);
            drawLegOnCanvas(context, 217, 350, 18, 140, 227, 490, 18, 100, 12, false);
        }

        function drawSkeleton() {
            drawSkeletonOnCanvas(ctx);
        }

        function drawSkeleton() {
            // Dark background for contrast
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bright white skeleton with thick outlines
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;

            // Skull - larger and centered
            ctx.beginPath();
            ctx.ellipse(200, 100, 70, 75, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Eyes - larger
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(170, 90, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(230, 90, 18, 0, Math.PI * 2);
            ctx.fill();

            // Nose - larger
            ctx.beginPath();
            ctx.moveTo(200, 110);
            ctx.lineTo(185, 135);
            ctx.lineTo(215, 135);
            ctx.closePath();
            ctx.fill();

            // Teeth - larger and more visible
            ctx.fillRect(165, 150, 15, 12);
            ctx.fillRect(185, 150, 15, 12);
            ctx.fillRect(200, 150, 15, 12);
            ctx.fillRect(220, 150, 15, 12);

            // Pirate Hat - larger
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(120, 35);
            ctx.lineTo(280, 35);
            ctx.lineTo(268, 75);
            ctx.lineTo(132, 75);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.ellipse(200, 35, 85, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 35px Arial';
            ctx.fillText('‚ò†', 180, 63);

            // Spine and Ribcage - thicker and more visible
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(190, 185, 20, 130);
            ctx.strokeRect(190, 185, 20, 130);

            // Ribs - larger and more prominent
            ctx.lineWidth = 6;
            for (let i = 0; i < 4; i++) {
                const y = 210 + i * 30;
                const width = 65 - i * 5;
                ctx.beginPath();
                ctx.ellipse(200, y, width, 12, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.lineWidth = 3;

            // Pelvis - larger
            ctx.beginPath();
            ctx.ellipse(200, 325, 50, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Arms - larger and more visible
            drawArm(110, 190, 80, 15, -35, 80, 205, 70, 15, true);
            drawArm(210, 190, 80, 15, 35, 250, 205, 70, 15, false);

            // Legs - larger
            drawLeg(165, 350, 18, 140, 155, 490, 18, 100, -12, true);
            drawLeg(217, 350, 18, 140, 227, 490, 18, 100, 12, false);
        }

        function drawSkeleton() {
            // Dark background for contrast
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bright white skeleton with thick outlines
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;

            // Skull - larger and centered
            ctx.beginPath();
            ctx.ellipse(200, 100, 70, 75, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Eyes - larger
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(170, 90, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(230, 90, 18, 0, Math.PI * 2);
            ctx.fill();

            // Nose - larger
            ctx.beginPath();
            ctx.moveTo(200, 110);
            ctx.lineTo(185, 135);
            ctx.lineTo(215, 135);
            ctx.closePath();
            ctx.fill();

            // Teeth - larger and more visible
            ctx.fillRect(165, 150, 15, 12);
            ctx.fillRect(185, 150, 15, 12);
            ctx.fillRect(200, 150, 15, 12);
            ctx.fillRect(220, 150, 15, 12);

            // Pirate Hat - larger
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(120, 35);
            ctx.lineTo(280, 35);
            ctx.lineTo(268, 75);
            ctx.lineTo(132, 75);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.ellipse(200, 35, 85, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 35px Arial';
            ctx.fillText('‚ò†', 180, 63);

            // Spine and Ribcage - thicker and more visible
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(190, 185, 20, 130);
            ctx.strokeRect(190, 185, 20, 130);

            // Ribs - larger and more prominent
            ctx.lineWidth = 6;
            for (let i = 0; i < 4; i++) {
                const y = 210 + i * 30;
                const width = 65 - i * 5;
                ctx.beginPath();
                ctx.ellipse(200, y, width, 12, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.lineWidth = 3;

            // Pelvis - larger
            ctx.beginPath();
            ctx.ellipse(200, 325, 50, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Arms - larger and more visible
            drawArm(110, 190, 80, 15, -35, 80, 205, 70, 15, true);
            drawArm(210, 190, 80, 15, 35, 250, 205, 70, 15, false);

            // Legs - larger
            drawLeg(165, 350, 18, 140, 155, 490, 18, 100, -12, true);
            drawLeg(217, 350, 18, 140, 227, 490, 18, 100, 12, false);
        }

        function drawArmOnCanvas(context, x1, y1, w1, h1, angle1, x2, y2, w2, h2, isLeft) {
            context.fillStyle = '#ffffff';
            context.lineWidth = 3;
            
            // Upper arm
            context.save();
            context.translate(x1 + w1/2, y1 + h1/2);
            context.fillRect(-w1/2, -h1/2, w1, h1);
            context.strokeRect(-w1/2, -h1/2, w1, h1);
            context.restore();

            // Lower arm
            context.save();
            context.translate(x2, y2);
            context.rotate(angle1 * Math.PI / 180);
            context.fillRect(0, 0, w2, h2);
            context.strokeRect(0, 0, w2, h2);
            context.restore();

            // Joints - larger
            context.beginPath();
            context.arc(x1 + (isLeft ? 0 : w1), y1 + h1/2, 14, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            // Hand - larger
            context.beginPath();
            if (isLeft) {
                context.ellipse(60, 230, 18, 12, 0, 0, Math.PI * 2);
            } else {
                context.ellipse(340, 230, 18, 12, 0, 0, Math.PI * 2);
            }
            context.fill();
            context.stroke();
        }

        function drawLegOnCanvas(context, x1, y1, w1, h1, x2, y2, w2, h2, angle, isLeft) {
            context.fillStyle = '#ffffff';
            context.lineWidth = 3;
            
            // Upper leg
            context.fillRect(x1, y1, w1, h1);
            context.strokeRect(x1, y1, w1, h1);

            // Lower leg
            context.save();
            context.translate(x2, y2);
            context.rotate(angle * Math.PI / 180);
            context.fillRect(0, 0, w2, h2);
            context.strokeRect(0, 0, w2, h2);
            context.restore();

            // Joints - larger
            context.beginPath();
            context.arc(x1 + w1/2, y1, 16, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            context.beginPath();
            context.arc(x2 + w2/2, y2, 16, 0, Math.PI * 2);
            context.fill();
            context.stroke();

            // Foot - larger
            context.beginPath();
            if (isLeft) {
                context.ellipse(145, 540, 24, 14, 0, 0, Math.PI * 2);
            } else {
                context.ellipse(255, 540, 24, 14, 0, 0, Math.PI * 2);
            }
            context.fill();
            context.stroke();
        }

        function drawArm(x1, y1, w1, h1, angle1, x2, y2, w2, h2, isLeft) {
            drawArmOnCanvas(ctx, x1, y1, w1, h1, angle1, x2, y2, w2, h2, isLeft);
        }

        function drawLeg(x1, y1, w1, h1, x2, y2, w2, h2, angle, isLeft) {
            drawLegOnCanvas(ctx, x1, y1, w1, h1, x2, y2, w2, h2, angle, isLeft);
        }

        function drawSandOverlay() {
            // Create sand texture on the sand canvas
            const gradient = sandCtx.createLinearGradient(0, 0, 0, sandCanvas.height);
            gradient.addColorStop(0, '#d4a574');
            gradient.addColorStop(0.5, '#c49a6c');
            gradient.addColorStop(1, '#b8915f');
            sandCtx.fillStyle = gradient;
            sandCtx.fillRect(0, 0, sandCanvas.width, sandCanvas.height);

            // Add sand texture particles
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * sandCanvas.width;
                const y = Math.random() * sandCanvas.height;
                const size = Math.random() * 2;
                const opacity = Math.random() * 0.3 + 0.1;
                sandCtx.fillStyle = `rgba(${100 + Math.random() * 100}, ${70 + Math.random() * 50}, ${40 + Math.random() * 30}, ${opacity})`;
                sandCtx.fillRect(x, y, size, size);
            }
        }

        function scratch(x, y) {
            if (gameComplete) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;

            // Remove sand from the sand layer
            sandCtx.globalCompositeOperation = 'destination-out';
            sandCtx.beginPath();
            sandCtx.arc(canvasX, canvasY, brushSize, 0, Math.PI * 2);
            sandCtx.fill();
            sandCtx.globalCompositeOperation = 'source-over';

            // Only redraw the scratched area, not the whole canvas
            redrawCanvas();
        }

        function redrawCanvas() {
            // Clear and redraw: skeleton + remaining sand
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSkeleton();
            ctx.drawImage(sandCanvas, 0, 0);
        }

        function updateDisplay() {
            // Composite: skeleton canvas + sand canvas onto main display
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(skeletonCanvas, 0, 0);
            ctx.drawImage(sandCanvas, 0, 0);
        }

        function scratch(x, y) {
            if (gameComplete) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;

            // Remove sand from the sand layer at brush position only
            sandCtx.globalCompositeOperation = 'destination-out';
            sandCtx.beginPath();
            sandCtx.arc(canvasX, canvasY, brushSize, 0, Math.PI * 2);
            sandCtx.fill();
            sandCtx.globalCompositeOperation = 'source-over';

            // Update display efficiently
            updateDisplay();

            // Check progress periodically (not every single scratch)
            progressCheckCounter++;
            if (progressCheckCounter % 10 === 0) {
                checkProgress();
            }
        }

        function checkProgress() {
            if (gameComplete) return;

            // Check how much of the SKELETON has been revealed (not total sand)
            // Sample key points on the skeleton to see if they're visible
            const skeletonPoints = [
                // Skull area
                {x: 200, y: 100},
                {x: 170, y: 90},
                {x: 230, y: 90},
                {x: 200, y: 135},
                // Hat
                {x: 200, y: 50},
                // Spine
                {x: 200, y: 200},
                {x: 200, y: 250},
                // Pelvis
                {x: 200, y: 325},
                // Left arm
                {x: 150, y: 190},
                {x: 100, y: 210},
                {x: 85, y: 230},
                // Right arm
                {x: 250, y: 190},
                {x: 300, y: 210},
                {x: 315, y: 230},
                // Left leg
                {x: 180, y: 380},
                {x: 175, y: 450},
                {x: 165, y: 520},
                // Right leg
                {x: 220, y: 380},
                {x: 225, y: 450},
                {x: 240, y: 520}
            ];

            let revealedPoints = 0;
            const imageData = sandCtx.getImageData(0, 0, sandCanvas.width, sandCanvas.height);

            skeletonPoints.forEach(point => {
                const index = (point.y * sandCanvas.width + point.x) * 4 + 3; // Alpha channel
                if (imageData.data[index] < 128) {
                    revealedPoints++;
                }
            });

            const percentage = Math.floor((revealedPoints / skeletonPoints.length) * 100);
            updateProgress(percentage);

            // Complete when 100% of skeleton points are revealed
            if (percentage >= 100 && !gameComplete) {
                gameComplete = true;
                setTimeout(() => {
                    victoryMessage.classList.add('show');
                    canvas.classList.add('skeleton-dance');
                }, 500);
            }
        }

        function updateProgress(percentage = 0) {
            progressFill.style.width = percentage + '%';
            progressFill.textContent = percentage + '%';
        }

        function revealAll() {
            // Clear all sand
            sandCtx.clearRect(0, 0, sandCanvas.width, sandCanvas.height);
            
            // Update display to show skeleton without sand
            updateDisplay();
            
            updateProgress(100);
            gameComplete = true;
            victoryMessage.classList.add('show');
            canvas.classList.add('skeleton-dance');
        }

        function resetGame() {
            canvas.classList.remove('skeleton-dance');
            initGame();
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            scratch(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                scratch(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            scratch(touch.clientX, touch.clientY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const touch = e.touches[0];
                scratch(touch.clientX, touch.clientY);
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });

        // Initialize game on load
        initGame();

        // NAVIGATION
        function showExcavationGame() {
            document.getElementById('excavation-game').classList.add('active');
            document.getElementById('match-game').classList.remove('active');
            document.getElementById('whack-game').classList.remove('active');
            document.getElementById('treasure-game').classList.remove('active');
            document.getElementById('brook-game').classList.remove('active');
            document.getElementById('rhythm-game').classList.remove('active');
            document.getElementById('nav-excavation').classList.add('active');
            document.getElementById('nav-flags').classList.remove('active');
            document.getElementById('nav-whack').classList.remove('active');
            document.getElementById('nav-treasure').classList.remove('active');
            document.getElementById('nav-brook').classList.remove('active');
            document.getElementById('nav-rhythm').classList.remove('active');
        }

        function showTreasureGame() {
            document.getElementById('excavation-game').classList.remove('active');
            document.getElementById('match-game').classList.remove('active');
            document.getElementById('whack-game').classList.remove('active');
            document.getElementById('treasure-game').classList.add('active');
            document.getElementById('brook-game').classList.remove('active');
            document.getElementById('rhythm-game').classList.remove('active');
            document.getElementById('nav-excavation').classList.remove('active');
            document.getElementById('nav-flags').classList.remove('active');
            document.getElementById('nav-whack').classList.remove('active');
            document.getElementById('nav-treasure').classList.add('active');
            document.getElementById('nav-brook').classList.remove('active');
            document.getElementById('nav-rhythm').classList.remove('active');
            
            if (!treasureGameInitialized) {
                initTreasureGame();
            }
        }

        function showBrookGame() {
            document.getElementById('excavation-game').classList.remove('active');
            document.getElementById('match-game').classList.remove('active');
            document.getElementById('whack-game').classList.remove('active');
            document.getElementById('treasure-game').classList.remove('active');
            document.getElementById('brook-game').classList.add('active');
            document.getElementById('rhythm-game').classList.remove('active');
            document.getElementById('nav-excavation').classList.remove('active');
            document.getElementById('nav-flags').classList.remove('active');
            document.getElementById('nav-whack').classList.remove('active');
            document.getElementById('nav-treasure').classList.remove('active');
            document.getElementById('nav-brook').classList.add('active');
            document.getElementById('nav-rhythm').classList.remove('active');
            
            if (!brookGameInitialized) {
                initBrookGame();
            }
        }

        function showRhythmGame() {
            document.getElementById('excavation-game').classList.remove('active');
            document.getElementById('match-game').classList.remove('active');
            document.getElementById('whack-game').classList.remove('active');
            document.getElementById('treasure-game').classList.remove('active');
            document.getElementById('brook-game').classList.remove('active');
            document.getElementById('rhythm-game').classList.add('active');
            document.getElementById('nav-excavation').classList.remove('active');
            document.getElementById('nav-flags').classList.remove('active');
            document.getElementById('nav-whack').classList.remove('active');
            document.getElementById('nav-treasure').classList.remove('active');
            document.getElementById('nav-brook').classList.remove('active');
            document.getElementById('nav-rhythm').classList.add('active');
            
            if (!rhythmGameInitialized) {
                initRhythmGame();
            }
        }

        function showWhackGame() {
            document.getElementById('excavation-game').classList.remove('active');
            document.getElementById('match-game').classList.remove('active');
            document.getElementById('whack-game').classList.add('active');
            document.getElementById('treasure-game').classList.remove('active');
            document.getElementById('brook-game').classList.remove('active');
            document.getElementById('rhythm-game').classList.remove('active');
            document.getElementById('nav-excavation').classList.remove('active');
            document.getElementById('nav-flags').classList.remove('active');
            document.getElementById('nav-whack').classList.add('active');
            document.getElementById('nav-treasure').classList.remove('active');
            document.getElementById('nav-brook').classList.remove('active');
            document.getElementById('nav-rhythm').classList.remove('active');
            
            if (!whackGameInitialized) {
                initWhackGame();
            }
        }

        function showFlagGame() {
            document.getElementById('excavation-game').classList.remove('active');
            document.getElementById('match-game').classList.add('active');
            document.getElementById('whack-game').classList.remove('active');
            document.getElementById('treasure-game').classList.remove('active');
            document.getElementById('brook-game').classList.remove('active');
            document.getElementById('rhythm-game').classList.remove('active');
            document.getElementById('nav-excavation').classList.remove('active');
            document.getElementById('nav-flags').classList.add('active');
            document.getElementById('nav-whack').classList.remove('active');
            document.getElementById('nav-treasure').classList.remove('active');
            document.getElementById('nav-brook').classList.remove('active');
            document.getElementById('nav-rhythm').classList.remove('active');
            
            if (flagCards.length === 0) {
                initMatchGame();
            }
        }

        // MATCHING GAME
        const flagDesigns = [
            `<svg viewBox="0 0 200 150" class="flag-svg">
                <rect width="200" height="150" fill="#1a1a1a"/>
                <ellipse cx="100" cy="60" rx="30" ry="35" fill="#f0f0f0"/>
                <circle cx="90" cy="55" r="9" fill="#1a1a1a"/>
                <circle cx="88" cy="53" r="3" fill="#fff"/>
                <circle cx="110" cy="55" r="9" fill="#1a1a1a"/>
                <circle cx="108" cy="53" r="3" fill="#fff"/>
                <ellipse cx="100" cy="78" rx="15" ry="8" fill="#ff69b4"/>
                <path d="M 85,75 Q 100,85 115,75" stroke="#1a1a1a" stroke-width="2" fill="none"/>
                <rect x="70" y="95" width="60" height="6" fill="#f0f0f0" transform="rotate(45 100 98)"/>
                <rect x="70" y="95" width="60" height="6" fill="#f0f0f0" transform="rotate(-45 100 98)"/>
            </svg>`,
            
            `<svg viewBox="0 0 200 150" class="flag-svg">
                <rect width="200" height="150" fill="#8b0000"/>
                <ellipse cx="100" cy="70" rx="28" ry="32" fill="#f5f5dc"/>
                <text x="83" y="72" font-size="18" fill="#ff1493">‚ù§</text>
                <text x="103" y="72" font-size="18" fill="#ff1493">‚ù§</text>
                <path d="M 85,80 Q 100,88 115,80" stroke="#1a1a1a" stroke-width="3" fill="none"/>
                <ellipse cx="100" cy="88" rx="8" ry="5" fill="#ff69b4"/>
                <line x1="70" y1="50" x2="130" y2="50" stroke="#ffd700" stroke-width="3"/>
                <rect x="75" y="100" width="50" height="5" fill="#f5f5dc" transform="rotate(45 100 102)"/>
                <rect x="75" y="100" width="50" height="5" fill="#f5f5dc" transform="rotate(-45 100 102)"/>
            </svg>`,
            
            `<svg viewBox="0 0 200 150" class="flag-svg">
                <rect width="200" height="150" fill="#2c1810"/>
                <ellipse cx="100" cy="65" rx="30" ry="33" fill="#e8e8e8"/>
                <circle cx="90" cy="60" r="10" fill="#fff" stroke="#000" stroke-width="2"/>
                <circle cx="110" cy="60" r="10" fill="#fff" stroke="#000" stroke-width="2"/>
                <path d="M 90,60 Q 88,58 86,60" stroke="#000" stroke-width="2" fill="none"/>
                <path d="M 110,60 Q 108,58 106,60" stroke="#000" stroke-width="2" fill="none"/>
                <ellipse cx="100" cy="75" rx="12" ry="6" fill="#1a1a1a"/>
                <path d="M 85,83 Q 100,78 115,83" stroke="#1a1a1a" stroke-width="2" fill="none"/>
                <line x1="75" y1="45" x2="85" y2="50" stroke="#ffd700" stroke-width="3"/>
                <line x1="115" y1="50" x2="125" y1="45" stroke="#ffd700" stroke-width="3"/>
            </svg>`,
            
            `<svg viewBox="0 0 200 150" class="flag-svg">
                <rect width="200" height="150" fill="#1a1a2e"/>
                <ellipse cx="100" cy="70" rx="30" ry="33" fill="#f0f0f0"/>
                <circle cx="90" cy="65" r="8" fill="#1a1a1a"/>
                <rect x="105" y="62" width="15" height="10" fill="#1a1a1a" rx="2"/>
                <line x1="95" y1="67" x2="120" y2="67" stroke="#1a1a1a" stroke-width="2"/>
                <polygon points="100,77 95,85 105,85" fill="#1a1a1a"/>
                <rect x="88" y="90" width="8" height="6" fill="#1a1a1a"/>
                <rect x="104" y="90" width="8" height="6" fill="#1a1a1a"/>
                <circle cx="100" cy="35" r="8" fill="#ffd700"/>
            </svg>`,
            
            `<svg viewBox="0 0 200 150" class="flag-svg">
                <rect width="200" height="150" fill="#000000"/>
                <ellipse cx="100" cy="65" rx="28" ry="32" fill="#ffffff"/>
                <circle cx="88" cy="58" r="8" fill="#1a1a1a"/>
                <circle cx="112" cy="58" r="8" fill="#1a1a1a"/>
                <line x1="88" y1="53" x2="88" y2="48" stroke="#000" stroke-width="2"/>
                <line x1="112" y1="53" x2="112" y2="48" stroke="#000" stroke-width="2"/>
                <polygon points="100,70 95,78 105,78" fill="#1a1a1a"/>
                <rect x="95" y="82" width="5" height="10" fill="#fff" stroke="#000" stroke-width="1"/>
                <rect x="100" y="82" width="5" height="10" fill="#fff" stroke="#000" stroke-width="1"/>
                <path d="M 85,80 L 85,85 L 90,85" stroke="#000" stroke-width="2" fill="none"/>
                <path d="M 115,80 L 115,85 L 110,85" stroke="#000" stroke-width="2" fill="none"/>
            </svg>`,
            
            `<svg viewBox="0 0 200 150" class="flag-svg">
                <rect width="200" height="150" fill="#0f4d0f"/>
                <ellipse cx="100" cy="68" rx="27" ry="30" fill="#90ee90"/>
                <circle cx="90" cy="62" r="7" fill="#000"/>
                <circle cx="110" cy="62" r="7" fill="#000"/>
                <polygon points="100,72 96,80 104,80" fill="#000"/>
                <path d="M 75,82 Q 85,88 100,86 Q 115,88 125,82" stroke="#1a1a1a" stroke-width="4" fill="none"/>
                <ellipse cx="85" cy="84" rx="8" ry="4" fill="#1a1a1a"/>
                <ellipse cx="115" cy="84" rx="8" ry="4" fill="#1a1a1a"/>
                <rect x="75" y="105" width="50" height="5" fill="#90ee90" transform="rotate(45 100 107)"/>
                <rect x="75" y="105" width="50" height="5" fill="#90ee90" transform="rotate(-45 100 107)"/>
            </svg>`
        ];

        let flagCards = [];
        let selectedCards = [];
        let matchedPairs = 0;

        function initMatchGame() {
            flagCards = [];
            for (let i = 0; i < 6; i++) {
                flagCards.push({id: i, design: flagDesigns[i]});
                flagCards.push({id: i, design: flagDesigns[i]});
            }
            
            flagCards.sort(() => Math.random() - 0.5);
            
            const grid = document.getElementById('flagGrid');
            grid.innerHTML = '';
            
            flagCards.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'flag-card';
                cardDiv.innerHTML = `
                    <div class="card-inner">
                        <div class="card-face card-front">
                            <div class="skull-icon">‚ò†Ô∏è</div>
                        </div>
                        <div class="card-face card-back">
                            ${card.design}
                        </div>
                    </div>
                `;
                cardDiv.dataset.id = card.id;
                cardDiv.dataset.index = index;
                cardDiv.addEventListener('click', () => selectCard(cardDiv, card.id, index));
                grid.appendChild(cardDiv);
            });
            
            selectedCards = [];
            matchedPairs = 0;
            document.getElementById('pairsCount').textContent = '0';
            document.getElementById('match-victory').style.display = 'none';
        }

        function selectCard(cardElement, id, index) {
            if (cardElement.classList.contains('matched') || 
                cardElement.classList.contains('flipped') ||
                selectedCards.length >= 2) {
                return;
            }
            
            cardElement.classList.add('flipped');
            selectedCards.push({element: cardElement, id: id, index: index});
            
            if (selectedCards.length === 2) {
                setTimeout(checkMatch, 1000);
            }
        }

        function checkMatch() {
            const [card1, card2] = selectedCards;
            
            if (card1.id === card2.id && card1.index !== card2.index) {
                card1.element.classList.add('matched');
                card2.element.classList.add('matched');
                matchedPairs++;
                document.getElementById('pairsCount').textContent = matchedPairs;
                
                if (matchedPairs === 6) {
                    document.getElementById('match-victory').style.display = 'block';
                }
            } else {
                card1.element.classList.add('wrong');
                card2.element.classList.add('wrong');
                
                setTimeout(() => {
                    card1.element.classList.remove('flipped', 'wrong');
                    card2.element.classList.remove('flipped', 'wrong');
                }, 800);
            }
            
            selectedCards = [];
        }

        function resetMatchGame() {
            initMatchGame();
        }

        function closeVictory() {
            victoryMessage.classList.remove('show');
        }

        function closeMatchVictory() {
            document.getElementById('match-victory').style.display = 'none';
        }

        function closeWhackVictory() {
            document.getElementById('whack-victory').style.display = 'none';
        }

        // WHACK-A-SKELETON GAME
        let whackGameInitialized = false;
        let whackScore = 0;
        let whackTime = 60;
        let whackCombo = 0;
        let whackInterval;
        let whackTimer;
        let activeSkeletons = [];
        let totalWhacks = 0;
        let gameActive = false;

        function initWhackGame() {
            whackGameInitialized = true;
            const gravesGrid = document.getElementById('gravesGrid');
            gravesGrid.innerHTML = '';

            // Create 9 graves
            for (let i = 0; i < 9; i++) {
                const grave = document.createElement('div');
                grave.className = 'grave';
                grave.innerHTML = `
                    <div class="skeleton-popup" data-grave="${i}">
                        <div class="skeleton-head">
                            <div class="skeleton-eye left"></div>
                            <div class="skeleton-eye right"></div>
                            <div class="skeleton-nose"></div>
                            <div class="skeleton-teeth">
                                <div class="skeleton-tooth"></div>
                                <div class="skeleton-tooth"></div>
                                <div class="skeleton-tooth"></div>
                                <div class="skeleton-tooth"></div>
                            </div>
                        </div>
                    </div>
                    <div class="grave-stone">ü™¶</div>
                    <div class="grave-base"></div>
                `;
                gravesGrid.appendChild(grave);

                // Add click handler to skeleton
                const skeleton = grave.querySelector('.skeleton-popup');
                skeleton.addEventListener('click', () => whackSkeleton(i));
                skeleton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    whackSkeleton(i);
                });
            }
        }

        function startWhackGame() {
            gameActive = true;
            whackScore = 0;
            whackTime = 60;
            whackCombo = 0;
            totalWhacks = 0;
            activeSkeletons = [];

            updateWhackDisplay();

            document.getElementById('whack-start-btn').style.display = 'none';
            document.getElementById('whack-reset-btn').style.display = 'none';
            document.getElementById('whack-victory').style.display = 'none';

            // Start timer
            whackTimer = setInterval(() => {
                whackTime--;
                document.getElementById('whack-time').textContent = whackTime;

                if (whackTime <= 0) {
                    endWhackGame();
                }
            }, 1000);

            // Start spawning skeletons
            spawnSkeleton();
            whackInterval = setInterval(spawnSkeleton, 1200);
        }

        function spawnSkeleton() {
            if (!gameActive) return;

            // Random grave
            const graveIndex = Math.floor(Math.random() * 9);
            
            // Don't spawn if already active
            if (activeSkeletons.includes(graveIndex)) return;

            const skeleton = document.querySelector(`[data-grave="${graveIndex}"]`);
            skeleton.classList.add('active');
            activeSkeletons.push(graveIndex);

            // Auto hide after random time (1-2.5 seconds)
            const hideTime = 1000 + Math.random() * 1500;
            setTimeout(() => {
                if (skeleton.classList.contains('active')) {
                    skeleton.classList.remove('active');
                    activeSkeletons = activeSkeletons.filter(i => i !== graveIndex);
                    // Miss - reset combo
                    whackCombo = 0;
                    updateWhackDisplay();
                }
            }, hideTime);
        }

        function whackSkeleton(graveIndex) {
            if (!gameActive) return;

            const skeleton = document.querySelector(`[data-grave="${graveIndex}"]`);
            
            if (!skeleton.classList.contains('active')) return;
            if (skeleton.classList.contains('whacked')) return;

            // Calculate points based on combo
            const basePoints = 100;
            const comboBonus = whackCombo * 50;
            const points = basePoints + comboBonus;

            whackScore += points;
            whackCombo++;
            totalWhacks++;

            // Show points popup
            showPoints(skeleton, points);

            // Whack animation
            skeleton.classList.add('whacked');
            skeleton.classList.remove('active');
            activeSkeletons = activeSkeletons.filter(i => i !== graveIndex);

            // Reset skeleton after animation
            setTimeout(() => {
                skeleton.classList.remove('whacked');
            }, 400);

            updateWhackDisplay();
        }

        function showPoints(element, points) {
            const pointsPopup = document.createElement('div');
            pointsPopup.className = 'points-popup';
            pointsPopup.textContent = '+' + points;
            element.appendChild(pointsPopup);

            setTimeout(() => {
                pointsPopup.remove();
            }, 1000);
        }

        function updateWhackDisplay() {
            document.getElementById('whack-score').textContent = whackScore;
            document.getElementById('whack-combo').textContent = whackCombo + 'x';
        }

        function endWhackGame() {
            gameActive = false;
            clearInterval(whackTimer);
            clearInterval(whackInterval);

            // Hide all active skeletons
            document.querySelectorAll('.skeleton-popup.active').forEach(skeleton => {
                skeleton.classList.remove('active');
            });

            activeSkeletons = [];

            // Show game over
            document.getElementById('final-score').textContent = whackScore;
            document.getElementById('final-whacks').textContent = totalWhacks;
            document.getElementById('whack-victory').style.display = 'block';
            document.getElementById('whack-reset-btn').style.display = 'inline-block';
        }

        function resetWhackGame() {
            if (gameActive) {
                endWhackGame();
            }

            whackScore = 0;
            whackTime = 60;
            whackCombo = 0;
            totalWhacks = 0;

            updateWhackDisplay();
            document.getElementById('whack-time').textContent = whackTime;
            document.getElementById('whack-start-btn').style.display = 'inline-block';
            document.getElementById('whack-reset-btn').style.display = 'none';
            document.getElementById('whack-victory').style.display = 'none';
        }

        function closeTreasureVictory() {
            document.getElementById('treasure-victory').style.display = 'none';
        }

        // TREASURE HUNT GAME
        let treasureGameInitialized = false;
        const treasureCanvas = document.getElementById('treasureCanvas');
        const treasureCtx = treasureCanvas.getContext('2d', { willReadFrequently: true });
        
        let treasureSandCanvas;
        let treasureSandCtx;
        let treasureBackCanvas;
        let treasureBackCtx;
        
        let treasuresFound = 0;
        let treasureComplete = false;
        let treasureItems = [];
        
        const treasureEmojis = ['üí∞', 'üíé', 'üëë', 'üìø', 'üíç', 'üèÜ', 'üëí', 'üê≠'];
        const treasureBrushSize = 30;

        function initTreasureGame() {
            treasureGameInitialized = true;
            treasureComplete = false;
            treasuresFound = 0;
            treasureCheckCounter = 0;
            
            // Create canvases
            treasureBackCanvas = document.createElement('canvas');
            treasureBackCanvas.width = treasureCanvas.width;
            treasureBackCanvas.height = treasureCanvas.height;
            treasureBackCtx = treasureBackCanvas.getContext('2d');
            
            treasureSandCanvas = document.createElement('canvas');
            treasureSandCanvas.width = treasureCanvas.width;
            treasureSandCanvas.height = treasureCanvas.height;
            treasureSandCtx = treasureSandCanvas.getContext('2d');
            
            // Generate random treasure positions
            generateTreasures();
            
            // Draw background with treasures
            drawTreasureBackground();
            
            // Draw sand overlay
            drawTreasureSand();
            
            // Initial display
            updateTreasureDisplay();
            
            // Reset UI
            treasureEmojis.forEach((emoji, i) => {
                document.getElementById(`treasure-${i}`).classList.remove('found');
            });
            document.getElementById('treasure-found').textContent = '0 / 8';
            document.getElementById('treasure-victory').style.display = 'none';
        }

        function generateTreasures() {
            treasureItems = [];
            const padding = 60;
            const minDistance = 100;
            
            treasureEmojis.forEach((emoji, index) => {
                let validPosition = false;
                let x, y;
                let attempts = 0;
                
                while (!validPosition && attempts < 100) {
                    x = padding + Math.random() * (treasureCanvas.width - padding * 2);
                    y = padding + Math.random() * (treasureCanvas.height - padding * 2);
                    
                    // Check distance from other treasures
                    validPosition = true;
                    for (let other of treasureItems) {
                        const dist = Math.sqrt(Math.pow(x - other.x, 2) + Math.pow(y - other.y, 2));
                        if (dist < minDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }
                
                treasureItems.push({
                    emoji: emoji,
                    x: x,
                    y: y,
                    found: false,
                    index: index
                });
            });
        }

        function drawTreasureBackground() {
            // Much darker background for contrast with sand
            treasureBackCtx.fillStyle = '#2a1810';
            treasureBackCtx.fillRect(0, 0, treasureCanvas.width, treasureCanvas.height);
            
            // Add some dark texture
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * treasureCanvas.width;
                const y = Math.random() * treasureCanvas.height;
                const size = Math.random() * 3;
                const opacity = Math.random() * 0.2;
                treasureBackCtx.fillStyle = `rgba(${30 + Math.random() * 40}, ${20 + Math.random() * 30}, ${10 + Math.random() * 20}, ${opacity})`;
                treasureBackCtx.fillRect(x, y, size, size);
            }
            
            // Draw bright circles behind treasures for visibility
            treasureItems.forEach(item => {
                treasureBackCtx.fillStyle = '#f5e6d3';
                treasureBackCtx.beginPath();
                treasureBackCtx.arc(item.x, item.y, 35, 0, Math.PI * 2);
                treasureBackCtx.fill();
                
                // Add golden glow
                treasureBackCtx.shadowColor = 'rgba(255, 215, 0, 0.6)';
                treasureBackCtx.shadowBlur = 15;
                treasureBackCtx.beginPath();
                treasureBackCtx.arc(item.x, item.y, 35, 0, Math.PI * 2);
                treasureBackCtx.fill();
                treasureBackCtx.shadowBlur = 0;
            });
            
            // Draw treasures on top of bright backgrounds
            treasureBackCtx.font = 'bold 50px Arial';
            treasureBackCtx.textAlign = 'center';
            treasureBackCtx.textBaseline = 'middle';
            
            treasureItems.forEach(item => {
                // Draw custom mouse for the last item instead of emoji
                if (item.index === 7) {
                    drawMouse(treasureBackCtx, item.x, item.y);
                } else {
                    treasureBackCtx.fillText(item.emoji, item.x, item.y);
                }
            });
        }

        function drawMouse(ctx, x, y) {
            // Black mouse face with big round ears
            
            // Left ear
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x - 25, y - 20, 18, 0, Math.PI * 2);
            ctx.fill();
            
            // Right ear
            ctx.beginPath();
            ctx.arc(x + 25, y - 20, 18, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.beginPath();
            ctx.arc(x, y, 22, 0, Math.PI * 2);
            ctx.fill();
            
            // Tan/beige mouth area
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(x, y + 8, 12, 0, Math.PI);
            ctx.fill();
            
            // Small black nose
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x, y + 3, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // White eyes
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x - 8, y - 3, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8, y - 3, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Black pupils
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x - 8, y - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 8, y - 3, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTreasureSand() {
            // Sand gradient
            const gradient = treasureSandCtx.createLinearGradient(0, 0, 0, treasureCanvas.height);
            gradient.addColorStop(0, '#d4a574');
            gradient.addColorStop(0.5, '#c49a6c');
            gradient.addColorStop(1, '#b8915f');
            treasureSandCtx.fillStyle = gradient;
            treasureSandCtx.fillRect(0, 0, treasureCanvas.width, treasureCanvas.height);
            
            // Add texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * treasureCanvas.width;
                const y = Math.random() * treasureCanvas.height;
                const size = Math.random() * 2;
                const opacity = Math.random() * 0.3 + 0.1;
                treasureSandCtx.fillStyle = `rgba(${100 + Math.random() * 100}, ${70 + Math.random() * 50}, ${40 + Math.random() * 30}, ${opacity})`;
                treasureSandCtx.fillRect(x, y, size, size);
            }
        }

        function updateTreasureDisplay() {
            treasureCtx.clearRect(0, 0, treasureCanvas.width, treasureCanvas.height);
            treasureCtx.drawImage(treasureBackCanvas, 0, 0);
            treasureCtx.drawImage(treasureSandCanvas, 0, 0);
        }

        let treasureCheckCounter = 0;

        function scratchTreasure(x, y) {
            if (treasureComplete) return;
            
            const rect = treasureCanvas.getBoundingClientRect();
            const scaleX = treasureCanvas.width / rect.width;
            const scaleY = treasureCanvas.height / rect.height;
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;
            
            // Remove sand
            treasureSandCtx.globalCompositeOperation = 'destination-out';
            treasureSandCtx.beginPath();
            treasureSandCtx.arc(canvasX, canvasY, treasureBrushSize, 0, Math.PI * 2);
            treasureSandCtx.fill();
            treasureSandCtx.globalCompositeOperation = 'source-over';
            
            updateTreasureDisplay();
            
            // Check treasures periodically (every 10 scratches) for performance
            treasureCheckCounter++;
            if (treasureCheckCounter % 10 === 0) {
                checkTreasureRevealed();
            }
        }

        function checkTreasureRevealed() {
            treasureItems.forEach(item => {
                if (item.found) return;
                
                // Check if treasure is 95% uncovered by sampling points around it
                const samplePoints = [];
                const radius = 25; // Sample area around treasure center
                const gridSize = 5; // 5x5 grid of sample points
                
                for (let dy = -radius; dy <= radius; dy += radius / (gridSize / 2)) {
                    for (let dx = -radius; dx <= radius; dx += radius / (gridSize / 2)) {
                        const sampleX = Math.floor(item.x + dx);
                        const sampleY = Math.floor(item.y + dy);
                        samplePoints.push({x: sampleX, y: sampleY});
                    }
                }
                
                // Count how many sample points are uncovered (sand removed)
                let uncoveredPoints = 0;
                const imageData = treasureSandCtx.getImageData(0, 0, treasureCanvas.width, treasureCanvas.height);
                
                samplePoints.forEach(point => {
                    if (point.x >= 0 && point.x < treasureCanvas.width && 
                        point.y >= 0 && point.y < treasureCanvas.height) {
                        const index = (point.y * treasureCanvas.width + point.x) * 4 + 3; // Alpha channel
                        if (imageData.data[index] < 128) {
                            uncoveredPoints++;
                        }
                    }
                });
                
                const percentUncovered = (uncoveredPoints / samplePoints.length) * 100;
                
                // Treasure found if 95% uncovered
                if (percentUncovered >= 95) {
                    item.found = true;
                    treasuresFound++;
                    
                    // Update UI
                    document.getElementById(`treasure-${item.index}`).classList.add('found');
                    document.getElementById('treasure-found').textContent = `${treasuresFound} / 8`;
                    
                    // Check if all found
                    if (treasuresFound === 8 && !treasureComplete) {
                        treasureComplete = true;
                        setTimeout(() => {
                            document.getElementById('treasure-victory').style.display = 'block';
                        }, 500);
                    }
                }
            });
        }

        function revealAllTreasure() {
            treasureSandCtx.clearRect(0, 0, treasureCanvas.width, treasureCanvas.height);
            updateTreasureDisplay();
            
            treasureItems.forEach(item => {
                if (!item.found) {
                    item.found = true;
                    treasuresFound++;
                    document.getElementById(`treasure-${item.index}`).classList.add('found');
                }
            });
            
            document.getElementById('treasure-found').textContent = '8 / 8';
            treasureComplete = true;
            document.getElementById('treasure-victory').style.display = 'block';
        }

        function resetTreasureGame() {
            initTreasureGame();
        }

        // Treasure canvas event listeners
        let treasureIsDrawing = false;

        treasureCanvas.addEventListener('mousedown', (e) => {
            treasureIsDrawing = true;
            scratchTreasure(e.clientX, e.clientY);
        });

        treasureCanvas.addEventListener('mousemove', (e) => {
            if (treasureIsDrawing) {
                scratchTreasure(e.clientX, e.clientY);
            }
        });

        treasureCanvas.addEventListener('mouseup', () => {
            treasureIsDrawing = false;
        });

        treasureCanvas.addEventListener('mouseleave', () => {
            treasureIsDrawing = false;
        });

        treasureCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            treasureIsDrawing = true;
            const touch = e.touches[0];
            scratchTreasure(touch.clientX, touch.clientY);
        });

        treasureCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (treasureIsDrawing) {
                const touch = e.touches[0];
                scratchTreasure(touch.clientX, touch.clientY);
            }
        });

        treasureCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            treasureIsDrawing = false;
        });

        function closeBrookVictory() {
            document.getElementById('brook-victory').style.display = 'none';
        }

        // FIND BROOK GAME
        let brookGameInitialized = false;
        const brookCanvas = document.getElementById('brookCanvas');
        const brookCtx = brookCanvas.getContext('2d');
        
        let specialSkeletons = []; // Track all 4 special skeletons
        let skeletons = [];
        let foundSkeletons = new Set(); // Track which ones have been found
        let brookGameActive = false;

        function initBrookGame() {
            brookGameInitialized = true;
            brookGameActive = true;
            foundSkeletons.clear();
            specialSkeletons = [];
            
            // Draw pirate ship deck background
            drawPirateShipDeck();
            
            // Generate MANY more skeletons (100-120 for maximum difficulty!)
            const numSkeletons = 100 + Math.floor(Math.random() * 21);
            skeletons = [];
            
            const gridSize = 48; // Adjusted for portrait and bigger skeletons
            const rows = Math.floor(brookCanvas.height / gridSize);
            const cols = Math.floor(brookCanvas.width / gridSize);
            const positions = [];
            
            // Create grid positions
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    positions.push({
                        x: col * gridSize + gridSize / 2 + (Math.random() - 0.5) * 12,
                        y: row * gridSize + gridSize / 2 + (Math.random() - 0.5) * 12
                    });
                }
            }
            
            // Shuffle positions
            positions.sort(() => Math.random() - 0.5);
            
            // Assign skeleton types - ensure special ones are placed
            let brookPlaced = false;
            let hatPlaced = false;
            let violinPlaced = false;
            let milkPlaced = false;
            
            for (let i = 0; i < Math.min(numSkeletons, positions.length); i++) {
                let type = 'normal';
                
                if (!brookPlaced && i >= 10) {
                    type = 'brook';
                    brookPlaced = true;
                    specialSkeletons.push({
                        type: 'brook',
                        x: positions[i].x,
                        y: positions[i].y,
                        radius: 35
                    });
                } else if (!hatPlaced && i >= 3) {
                    type = 'hat';
                    hatPlaced = true;
                    specialSkeletons.push({
                        type: 'hat',
                        x: positions[i].x,
                        y: positions[i].y,
                        radius: 35
                    });
                } else if (!violinPlaced && i >= 5) {
                    type = 'violin';
                    violinPlaced = true;
                    specialSkeletons.push({
                        type: 'violin',
                        x: positions[i].x,
                        y: positions[i].y,
                        radius: 35
                    });
                } else if (!milkPlaced && i >= 7) {
                    type = 'milk';
                    milkPlaced = true;
                    specialSkeletons.push({
                        type: 'milk',
                        x: positions[i].x,
                        y: positions[i].y,
                        radius: 35
                    });
                }
                
                skeletons.push({
                    x: positions[i].x,
                    y: positions[i].y,
                    type: type
                });
            }
            
            // Draw all skeletons
            skeletons.forEach(skeleton => {
                drawSkeletonBrook(skeleton.x, skeleton.y, skeleton.type);
            });
            
            // Reset UI
            document.getElementById('brook-found').textContent = '0 / 4';
            ['brook', 'hat', 'violin', 'milk'].forEach(type => {
                document.getElementById(`brook-icon-${type}`).classList.remove('found');
            });
            
            document.getElementById('brook-victory').style.display = 'none';
        }

        function drawPirateShipDeck() {
            // Wooden deck background
            brookCtx.fillStyle = '#8b6f47';
            brookCtx.fillRect(0, 0, brookCanvas.width, brookCanvas.height);
            
            // Wood grain texture
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * brookCanvas.width;
                const y = Math.random() * brookCanvas.height;
                const width = 2 + Math.random() * 3;
                const height = 0.5 + Math.random() * 1;
                brookCtx.fillStyle = `rgba(${70 + Math.random() * 30}, ${50 + Math.random() * 20}, ${30 + Math.random() * 15}, ${0.2 + Math.random() * 0.3})`;
                brookCtx.fillRect(x, y, width, height);
            }
            
            // Wooden planks - horizontal
            brookCtx.strokeStyle = '#5d4a33';
            brookCtx.lineWidth = 3;
            for (let y = 0; y < brookCanvas.height; y += 40) {
                brookCtx.beginPath();
                brookCtx.moveTo(0, y);
                brookCtx.lineTo(brookCanvas.width, y);
                brookCtx.stroke();
            }
            
            // Vertical plank separations (nails/joints)
            brookCtx.lineWidth = 2;
            for (let x = 100; x < brookCanvas.width; x += 120) {
                for (let y = 20; y < brookCanvas.height; y += 40) {
                    // Nail heads
                    brookCtx.fillStyle = '#2f2f2f';
                    brookCtx.beginPath();
                    brookCtx.arc(x, y, 2, 0, Math.PI * 2);
                    brookCtx.fill();
                }
            }
            
            // Jolly Roger flag in corner (Straw Hat Pirates style!)
            drawJollyRoger(50, 40);
            
            // Anchor in opposite corner
            drawAnchor(brookCanvas.width - 60, 50);
            
            // Barrel near bottom
            drawBarrel(brookCanvas.width - 70, brookCanvas.height - 60);
            
            // Coil of rope
            drawRope(60, brookCanvas.height - 50);
        }

        function drawJollyRoger(x, y) {
            brookCtx.save();
            brookCtx.translate(x, y);
            
            // Flag pole
            brookCtx.strokeStyle = '#8b7355';
            brookCtx.lineWidth = 3;
            brookCtx.beginPath();
            brookCtx.moveTo(0, 0);
            brookCtx.lineTo(0, -30);
            brookCtx.stroke();
            
            // Black flag
            brookCtx.fillStyle = '#000';
            brookCtx.fillRect(0, -30, 45, 30);
            
            // Straw Hat Pirates skull (simplified)
            brookCtx.fillStyle = '#fff';
            brookCtx.beginPath();
            brookCtx.arc(22, -20, 8, 0, Math.PI * 2);
            brookCtx.fill();
            
            // Eyes
            brookCtx.fillStyle = '#000';
            brookCtx.beginPath();
            brookCtx.arc(19, -22, 2, 0, Math.PI * 2);
            brookCtx.fill();
            brookCtx.beginPath();
            brookCtx.arc(25, -22, 2, 0, Math.PI * 2);
            brookCtx.fill();
            
            // Crossbones
            brookCtx.strokeStyle = '#fff';
            brookCtx.lineWidth = 2;
            brookCtx.beginPath();
            brookCtx.moveTo(15, -12);
            brookCtx.lineTo(29, -12);
            brookCtx.stroke();
            
            // Straw hat on skull
            brookCtx.fillStyle = '#d4a574';
            brookCtx.fillRect(15, -28, 14, 3);
            brookCtx.beginPath();
            brookCtx.arc(22, -28, 6, Math.PI, 0);
            brookCtx.fill();
            
            // Red ribbon
            brookCtx.fillStyle = '#dc143c';
            brookCtx.fillRect(17, -26, 10, 2);
            
            brookCtx.restore();
        }

        function drawAnchor(x, y) {
            brookCtx.save();
            brookCtx.translate(x, y);
            brookCtx.strokeStyle = '#4a4a4a';
            brookCtx.fillStyle = '#5a5a5a';
            brookCtx.lineWidth = 3;
            
            // Anchor shank
            brookCtx.beginPath();
            brookCtx.moveTo(0, -15);
            brookCtx.lineTo(0, 15);
            brookCtx.stroke();
            
            // Anchor ring
            brookCtx.beginPath();
            brookCtx.arc(0, -15, 5, 0, Math.PI * 2);
            brookCtx.stroke();
            
            // Anchor flukes
            brookCtx.beginPath();
            brookCtx.moveTo(-12, 15);
            brookCtx.lineTo(0, 15);
            brookCtx.lineTo(12, 15);
            brookCtx.stroke();
            
            brookCtx.beginPath();
            brookCtx.arc(-12, 15, 4, 0, Math.PI);
            brookCtx.fill();
            brookCtx.stroke();
            
            brookCtx.beginPath();
            brookCtx.arc(12, 15, 4, 0, Math.PI);
            brookCtx.fill();
            brookCtx.stroke();
            
            brookCtx.restore();
        }

        function drawBarrel(x, y) {
            brookCtx.save();
            brookCtx.translate(x, y);
            
            // Barrel body
            brookCtx.fillStyle = '#8b6f47';
            brookCtx.fillRect(-15, -20, 30, 40);
            
            // Barrel bands
            brookCtx.strokeStyle = '#4a4a4a';
            brookCtx.lineWidth = 2;
            for (let yPos of [-15, 0, 15]) {
                brookCtx.beginPath();
                brookCtx.moveTo(-15, yPos);
                brookCtx.lineTo(15, yPos);
                brookCtx.stroke();
            }
            
            // Barrel top
            brookCtx.fillStyle = '#6b5437';
            brookCtx.beginPath();
            brookCtx.ellipse(0, -20, 15, 6, 0, 0, Math.PI * 2);
            brookCtx.fill();
            brookCtx.stroke();
            
            brookCtx.restore();
        }

        function drawRope(x, y) {
            brookCtx.save();
            brookCtx.translate(x, y);
            
            // Coiled rope
            brookCtx.strokeStyle = '#d4a574';
            brookCtx.lineWidth = 4;
            
            for (let i = 0; i < 3; i++) {
                brookCtx.beginPath();
                brookCtx.arc(0, 0, 8 + i * 4, 0, Math.PI * 2);
                brookCtx.stroke();
            }
            
            brookCtx.restore();
        }

        function drawSkeletonBrook(x, y, type) {
            brookCtx.save();
            brookCtx.translate(x, y);
            
            // Full skeleton body - BIGGER for portrait
            const scale = 0.85; // Increased from 0.7 to 0.85
            
            // Skull
            brookCtx.fillStyle = '#f0f0f0';
            brookCtx.beginPath();
            brookCtx.ellipse(0, 0, 10 * scale, 12 * scale, 0, 0, Math.PI * 2);
            brookCtx.fill();
            brookCtx.strokeStyle = '#000';
            brookCtx.lineWidth = 0.8;
            brookCtx.stroke();
            
            // Eyes
            brookCtx.fillStyle = '#000';
            brookCtx.beginPath();
            brookCtx.arc(-4 * scale, -2 * scale, 2 * scale, 0, Math.PI * 2);
            brookCtx.fill();
            brookCtx.beginPath();
            brookCtx.arc(4 * scale, -2 * scale, 2 * scale, 0, Math.PI * 2);
            brookCtx.fill();
            
            // Nose
            brookCtx.beginPath();
            brookCtx.moveTo(0, 2 * scale);
            brookCtx.lineTo(-2 * scale, 5 * scale);
            brookCtx.lineTo(2 * scale, 5 * scale);
            brookCtx.closePath();
            brookCtx.fill();
            
            // Teeth
            for (let i = -4; i < 4; i += 2.5) {
                brookCtx.fillRect(i * scale, 8 * scale, 2 * scale, 2.5 * scale);
            }
            
            // Type-specific head accessories - LARGER and MORE VISIBLE
            if (type === 'brook') {
                // Black afro! (Soul King Brook) - SMALLER for difficulty
                brookCtx.fillStyle = '#000';
                brookCtx.beginPath();
                brookCtx.arc(0, -10 * scale, 12 * scale, 0, Math.PI * 2); // Reduced from 16 to 12
                brookCtx.fill();
                // Afro texture - fewer puffs
                for (let i = 0; i < 15; i++) { // Reduced from 25 to 15
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 5 * scale + Math.random() * 5 * scale; // Reduced from 7+7 to 5+5
                    const ax = Math.cos(angle) * radius;
                    const ay = -10 * scale + Math.sin(angle) * radius;
                    brookCtx.beginPath();
                    brookCtx.arc(ax, ay, (2 + Math.random() * 2) * scale, 0, Math.PI * 2); // Reduced from 2.5+2.5 to 2+2
                    brookCtx.fill();
                }
            } else if (type === 'hat') {
                // LARGER Straw hat (Luffy's hat reference!)
                brookCtx.fillStyle = '#d4a574';
                // Hat brim - BIGGER
                brookCtx.beginPath();
                brookCtx.ellipse(0, -14 * scale, 20 * scale, 6 * scale, 0, 0, Math.PI * 2);
                brookCtx.fill();
                brookCtx.strokeStyle = '#8b7355';
                brookCtx.lineWidth = 1.5;
                brookCtx.stroke();
                // Hat crown
                brookCtx.beginPath();
                brookCtx.arc(0, -18 * scale, 11 * scale, 0, Math.PI);
                brookCtx.fill();
                brookCtx.stroke();
                // PROMINENT Red ribbon - THICKER
                brookCtx.fillStyle = '#dc143c';
                brookCtx.fillRect(-14 * scale, -15 * scale, 28 * scale, 4 * scale);
            } else if (type === 'violin') {
                // LARGER Violin (Brook plays music!) - positioned to the side for visibility
                brookCtx.save();
                brookCtx.translate(-12 * scale, 18 * scale);
                brookCtx.rotate(-0.3);
                
                // Violin body - BIGGER
                brookCtx.fillStyle = '#cd853f';
                brookCtx.strokeStyle = '#8b4513';
                brookCtx.lineWidth = 1.5;
                
                // Top bout
                brookCtx.beginPath();
                brookCtx.ellipse(0, -6 * scale, 5 * scale, 8 * scale, 0, 0, Math.PI * 2);
                brookCtx.fill();
                brookCtx.stroke();
                
                // Bottom bout
                brookCtx.beginPath();
                brookCtx.ellipse(0, 6 * scale, 6 * scale, 10 * scale, 0, 0, Math.PI * 2);
                brookCtx.fill();
                brookCtx.stroke();
                
                // Neck
                brookCtx.fillStyle = '#8b4513';
                brookCtx.fillRect(-1.5 * scale, -14 * scale, 3 * scale, 8 * scale);
                
                // Strings
                brookCtx.strokeStyle = '#333';
                brookCtx.lineWidth = 0.8;
                for (let i = -2; i <= 2; i += 1.5) {
                    brookCtx.beginPath();
                    brookCtx.moveTo(i * scale, -14 * scale);
                    brookCtx.lineTo(i * scale, 16 * scale);
                    brookCtx.stroke();
                }
                
                brookCtx.restore();
            } else if (type === 'milk') {
                // LARGER Milk bottle (Brook loves milk for strong bones!)
                brookCtx.save();
                brookCtx.translate(12 * scale, 14 * scale);
                
                // Bottle body - BIGGER
                brookCtx.fillStyle = '#f8f8f8';
                brookCtx.fillRect(-4 * scale, 0, 8 * scale, 16 * scale);
                brookCtx.strokeStyle = '#ccc';
                brookCtx.lineWidth = 1;
                brookCtx.strokeRect(-4 * scale, 0, 8 * scale, 16 * scale);
                
                // Neck
                brookCtx.fillStyle = '#e8e8e8';
                brookCtx.fillRect(-3 * scale, -4 * scale, 6 * scale, 4 * scale);
                
                // Cap
                brookCtx.fillStyle = '#4169e1';
                brookCtx.fillRect(-3.5 * scale, -6 * scale, 7 * scale, 2.5 * scale);
                
                // BRIGHT Blue label - MORE VISIBLE
                brookCtx.fillStyle = '#1e90ff';
                brookCtx.fillRect(-3.5 * scale, 3 * scale, 7 * scale, 8 * scale);
                
                // "MILK" text
                brookCtx.fillStyle = '#fff';
                brookCtx.font = 'bold 3px Arial';
                brookCtx.textAlign = 'center';
                brookCtx.fillText('MILK', 0, 8 * scale);
                
                brookCtx.restore();
            }
            
            // Full skeleton body
            brookCtx.strokeStyle = '#f0f0f0';
            brookCtx.lineWidth = 1.5 * scale;
            
            // Spine
            brookCtx.beginPath();
            brookCtx.moveTo(0, 12 * scale);
            brookCtx.lineTo(0, 28 * scale);
            brookCtx.stroke();
            
            // Ribcage
            for (let i = 0; i < 3; i++) {
                brookCtx.beginPath();
                brookCtx.arc(0, (16 + i * 3.5) * scale, 5 * scale, Math.PI, 0);
                brookCtx.stroke();
            }
            
            // Arms
            brookCtx.beginPath();
            brookCtx.moveTo(-6 * scale, 16 * scale);
            brookCtx.lineTo(-10 * scale, 24 * scale);
            brookCtx.stroke();
            
            brookCtx.beginPath();
            brookCtx.moveTo(6 * scale, 16 * scale);
            brookCtx.lineTo(10 * scale, 24 * scale);
            brookCtx.stroke();
            
            // Legs
            brookCtx.beginPath();
            brookCtx.moveTo(-2.5 * scale, 28 * scale);
            brookCtx.lineTo(-4 * scale, 38 * scale);
            brookCtx.stroke();
            
            brookCtx.beginPath();
            brookCtx.moveTo(2.5 * scale, 28 * scale);
            brookCtx.lineTo(4 * scale, 38 * scale);
            brookCtx.stroke();
            
            brookCtx.restore();
        }

        function checkBrookClick(x, y) {
            if (!brookGameActive) return;
            
            const rect = brookCanvas.getBoundingClientRect();
            const scaleX = brookCanvas.width / rect.width;
            const scaleY = brookCanvas.height / rect.height;
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;
            
            // Check all special skeletons
            specialSkeletons.forEach(skeleton => {
                if (foundSkeletons.has(skeleton.type)) return; // Already found
                
                const distance = Math.sqrt(
                    Math.pow(canvasX - skeleton.x, 2) + 
                    Math.pow(canvasY - skeleton.y, 2)
                );
                
                if (distance < skeleton.radius) {
                    // Found one!
                    foundSkeletons.add(skeleton.type);
                    
                    // Update UI
                    document.getElementById(`brook-icon-${skeleton.type}`).classList.add('found');
                    document.getElementById('brook-found').textContent = `${foundSkeletons.size} / 4`;
                    
                    // Show marker
                    const marker = document.createElement('div');
                    marker.className = 'skeleton-marker';
                    marker.style.left = (skeleton.x / scaleX + rect.left - 30) + 'px';
                    marker.style.top = (skeleton.y / scaleY + rect.top - 30) + 'px';
                    marker.style.position = 'fixed';
                    document.body.appendChild(marker);
                    
                    setTimeout(() => {
                        marker.remove();
                    }, 600);
                    
                    // Check if all found
                    if (foundSkeletons.size === 4) {
                        brookGameActive = false;
                        setTimeout(() => {
                            document.getElementById('brook-victory').style.display = 'block';
                        }, 700);
                    }
                }
            });
        }

        function resetBrookGame() {
            brookGameActive = false;
            document.getElementById('brook-victory').style.display = 'none';
            initBrookGame();
        }

        // Brook canvas click handler
        brookCanvas.addEventListener('click', (e) => {
            checkBrookClick(e.clientX, e.clientY);
        });

        brookCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            checkBrookClick(touch.clientX, touch.clientY);
        }, { passive: false });

        function closeRhythmVictory() {
            document.getElementById('rhythm-victory').style.display = 'none';
        }

        // RHYTHM DANCE PARTY GAME
        let rhythmGameInitialized = false;
        const rhythmCanvas = document.getElementById('rhythmCanvas');
        const rhythmCtx = rhythmCanvas.getContext('2d');
        
        let rhythmScore = 0;
        let rhythmCombo = 0;
        let rhythmPerfect = 0;
        let rhythmActive = false;
        let danceSkeletons = [];
        let currentBeat = 0;
        
        const bpm = 80; // Slower tempo for easier gameplay

        // Simple beat sounds using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeatSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 440;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playHitSound(isPerfect) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = isPerfect ? 880 : 660;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        function initRhythmGame() {
            rhythmGameInitialized = true;
            rhythmCtx.fillStyle = '#0f0f1e';
            rhythmCtx.fillRect(0, 0, rhythmCanvas.width, rhythmCanvas.height);
            
            // Create 5 dancing skeletons with full bodies
            danceSkeletons = [
                {x: 100, y: 300, active: false, danceFrame: 0, armPhase: 0},
                {x: 225, y: 300, active: false, danceFrame: 0, armPhase: 1.5},
                {x: 350, y: 300, active: false, danceFrame: 0, armPhase: 3},
                {x: 475, y: 300, active: false, danceFrame: 0, armPhase: 4.5},
                {x: 600, y: 300, active: false, danceFrame: 0, armPhase: 2}
            ];
            
            drawRhythmScene();
        }

        function drawRhythmScene() {
            rhythmCtx.fillStyle = '#0f0f1e';
            rhythmCtx.fillRect(0, 0, rhythmCanvas.width, rhythmCanvas.height);
            
            // Draw wooden dance floor
            rhythmCtx.fillStyle = '#8b6f47';
            rhythmCtx.fillRect(0, 400, rhythmCanvas.width, 100);
            
            // Floor planks
            rhythmCtx.strokeStyle = '#5d4a33';
            rhythmCtx.lineWidth = 2;
            for (let y = 400; y < 500; y += 20) {
                rhythmCtx.beginPath();
                rhythmCtx.moveTo(0, y);
                rhythmCtx.lineTo(rhythmCanvas.width, y);
                rhythmCtx.stroke();
            }
            
            // Draw each full dancing skeleton
            danceSkeletons.forEach(skeleton => {
                drawFullDancingSkeleton(skeleton);
            });
        }

        function drawFullDancingSkeleton(skeleton) {
            rhythmCtx.save();
            rhythmCtx.translate(skeleton.x, skeleton.y);
            
            // Dance movements - slower bobbing
            const bounce = Math.sin(skeleton.danceFrame * 0.05) * 8;
            const sway = Math.sin(skeleton.danceFrame * 0.03) * 5;
            rhythmCtx.translate(sway, bounce);
            
            // Glow effect if active
            if (skeleton.active) {
                rhythmCtx.shadowColor = '#f0a500';
                rhythmCtx.shadowBlur = 30;
                rhythmCtx.strokeStyle = '#f0a500';
                rhythmCtx.lineWidth = 4;
                rhythmCtx.beginPath();
                rhythmCtx.arc(0, -40, 60, 0, Math.PI * 2);
                rhythmCtx.stroke();
            }
            
            rhythmCtx.shadowBlur = 0;
            
            // FULL SKELETON BODY
            
            // Skull
            rhythmCtx.fillStyle = '#ffffff';
            rhythmCtx.strokeStyle = '#000000';
            rhythmCtx.lineWidth = 2;
            rhythmCtx.beginPath();
            rhythmCtx.ellipse(0, -40, 18, 22, 0, 0, Math.PI * 2);
            rhythmCtx.fill();
            rhythmCtx.stroke();
            
            // Eyes
            rhythmCtx.fillStyle = '#000000';
            rhythmCtx.beginPath();
            rhythmCtx.arc(-8, -45, 4, 0, Math.PI * 2);
            rhythmCtx.fill();
            rhythmCtx.beginPath();
            rhythmCtx.arc(8, -45, 4, 0, Math.PI * 2);
            rhythmCtx.fill();
            
            // Nose - moved up
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(0, -38);
            rhythmCtx.lineTo(-3, -32);
            rhythmCtx.lineTo(3, -32);
            rhythmCtx.closePath();
            rhythmCtx.fill();
            
            // Teeth - moved up
            for (let i = -8; i < 8; i += 5) {
                rhythmCtx.fillRect(i, -28, 4, 3);
            }
            
            // Spine
            rhythmCtx.strokeStyle = '#ffffff';
            rhythmCtx.lineWidth = 3;
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(0, -18);
            rhythmCtx.lineTo(0, 20);
            rhythmCtx.stroke();
            
            // Ribcage
            rhythmCtx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                rhythmCtx.beginPath();
                rhythmCtx.arc(0, -10 + i * 8, 15 - i * 2, Math.PI, 0);
                rhythmCtx.stroke();
            }
            
            // Arms - animated dancing
            const armSwing = Math.sin(skeleton.danceFrame * 0.08 + skeleton.armPhase);
            rhythmCtx.lineWidth = 3;
            
            // Left arm
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(-10, -8);
            rhythmCtx.lineTo(-20 + armSwing * 15, 5 + armSwing * 10);
            rhythmCtx.stroke();
            
            // Left forearm
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(-20 + armSwing * 15, 5 + armSwing * 10);
            rhythmCtx.lineTo(-25 + armSwing * 20, 25 - armSwing * 5);
            rhythmCtx.stroke();
            
            // Right arm
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(10, -8);
            rhythmCtx.lineTo(20 - armSwing * 15, 5 - armSwing * 10);
            rhythmCtx.stroke();
            
            // Right forearm
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(20 - armSwing * 15, 5 - armSwing * 10);
            rhythmCtx.lineTo(25 - armSwing * 20, 25 + armSwing * 5);
            rhythmCtx.stroke();
            
            // Pelvis
            rhythmCtx.fillStyle = '#ffffff';
            rhythmCtx.beginPath();
            rhythmCtx.ellipse(0, 20, 12, 8, 0, 0, Math.PI * 2);
            rhythmCtx.fill();
            rhythmCtx.stroke();
            
            // Legs - slight dancing motion
            const legSwing = Math.sin(skeleton.danceFrame * 0.06) * 3;
            
            // Left leg
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(-6, 25);
            rhythmCtx.lineTo(-10 + legSwing, 55);
            rhythmCtx.stroke();
            
            // Left shin
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(-10 + legSwing, 55);
            rhythmCtx.lineTo(-12 + legSwing, 80);
            rhythmCtx.stroke();
            
            // Right leg
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(6, 25);
            rhythmCtx.lineTo(10 - legSwing, 55);
            rhythmCtx.stroke();
            
            // Right shin
            rhythmCtx.beginPath();
            rhythmCtx.moveTo(10 - legSwing, 55);
            rhythmCtx.lineTo(12 - legSwing, 80);
            rhythmCtx.stroke();
            
            // Feet
            rhythmCtx.fillStyle = '#ffffff';
            rhythmCtx.beginPath();
            rhythmCtx.ellipse(-12 + legSwing, 82, 8, 4, 0, 0, Math.PI * 2);
            rhythmCtx.fill();
            rhythmCtx.stroke();
            
            rhythmCtx.beginPath();
            rhythmCtx.ellipse(12 - legSwing, 82, 8, 4, 0, 0, Math.PI * 2);
            rhythmCtx.fill();
            rhythmCtx.stroke();
            
            rhythmCtx.restore();
        }

        function startRhythmGame() {
            rhythmActive = true;
            rhythmScore = 0;
            rhythmCombo = 0;
            rhythmPerfect = 0;
            currentBeat = 0;
            
            // Resume audio context (required for user interaction)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            updateRhythmDisplay();
            document.getElementById('rhythm-start-btn').style.display = 'none';
            
            playBeats();
        }

        function playBeats() {
            if (!rhythmActive || currentBeat >= 32) {
                endRhythmGame();
                return;
            }
            
            const skeleton = danceSkeletons[Math.floor(Math.random() * 5)];
            skeleton.active = true;
            skeleton.activeTime = Date.now();
            
            // Play beat sound
            playBeatSound();
            
            setTimeout(() => {
                if (skeleton.active) {
                    skeleton.active = false;
                    rhythmCombo = 0;
                    updateRhythmDisplay();
                }
            }, 600); // Longer window for slower tempo
            
            currentBeat++;
            setTimeout(playBeats, (60 / bpm) * 1000);
            
            const animate = () => {
                if (!rhythmActive) return;
                danceSkeletons.forEach(s => s.danceFrame++);
                drawRhythmScene();
                requestAnimationFrame(animate);
            };
            if (currentBeat === 1) animate();
        }

        rhythmCanvas.addEventListener('click', (e) => {
            if (!rhythmActive) return;
            const rect = rhythmCanvas.getBoundingClientRect();
            const scaleX = rhythmCanvas.width / rect.width;
            const scaleY = rhythmCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            danceSkeletons.forEach(s => {
                if (s.active && Math.hypot(x - s.x, y - s.y) < 50) {
                    const timing = Date.now() - s.activeTime;
                    const isPerfect = timing < 150;
                    rhythmScore += (isPerfect ? 100 : 50) * (1 + rhythmCombo * 0.1);
                    rhythmCombo++;
                    if (isPerfect) rhythmPerfect++;
                    s.active = false;
                    playHitSound(isPerfect); // Play hit sound
                    updateRhythmDisplay();
                }
            });
        });

        rhythmCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!rhythmActive) return;
            const touch = e.touches[0];
            const rect = rhythmCanvas.getBoundingClientRect();
            const scaleX = rhythmCanvas.width / rect.width;
            const scaleY = rhythmCanvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            danceSkeletons.forEach(s => {
                if (s.active && Math.hypot(x - s.x, y - s.y) < 50) {
                    const timing = Date.now() - s.activeTime;
                    const isPerfect = timing < 150;
                    rhythmScore += (isPerfect ? 100 : 50) * (1 + rhythmCombo * 0.1);
                    rhythmCombo++;
                    if (isPerfect) rhythmPerfect++;
                    s.active = false;
                    playHitSound(isPerfect);
                    updateRhythmDisplay();
                }
            });
        }, { passive: false });

        function updateRhythmDisplay() {
            document.getElementById('rhythm-score').textContent = Math.floor(rhythmScore);
            document.getElementById('rhythm-combo').textContent = rhythmCombo + 'x';
            document.getElementById('rhythm-perfect').textContent = rhythmPerfect;
        }

        function endRhythmGame() {
            rhythmActive = false;
            document.getElementById('rhythm-final-score').textContent = Math.floor(rhythmScore);
            document.getElementById('rhythm-final-perfect').textContent = rhythmPerfect;
            document.getElementById('rhythm-victory').style.display = 'block';
            document.getElementById('rhythm-reset-btn').style.display = 'inline-block';
        }

        function resetRhythmGame() {
            document.getElementById('rhythm-victory').style.display = 'none';
            document.getElementById('rhythm-start-btn').style.display = 'inline-block';
            document.getElementById('rhythm-reset-btn').style.display = 'none';
            initRhythmGame();
        }
    </script>
</body>
</html>